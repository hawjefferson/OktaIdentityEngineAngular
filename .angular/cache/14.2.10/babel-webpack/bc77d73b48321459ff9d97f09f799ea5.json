{"ast":null,"code":"import _regeneratorRuntime from \"/Users/jeffersonhaw/Documents/CebPacAngular/samples-js-angular/okta-hosted-login/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/jeffersonhaw/Documents/CebPacAngular/samples-js-angular/okta-hosted-login/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\nimport { clone } from '../util/object.js';\nimport { getOAuthUrls } from './util/oauth.js';\nimport AuthSdkError from '../errors/AuthSdkError.js';\nimport OAuthError from '../errors/OAuthError.js';\nimport { verifyToken } from './verifyToken.js';\nimport { getDefaultTokenParams } from './util/defaultTokenParams.js';\nimport 'tiny-emitter';\nimport 'js-cookie';\nimport 'cross-fetch';\n\nfunction validateResponse(res, oauthParams) {\n  if (res['error'] && res['error_description']) {\n    throw new OAuthError(res['error'], res['error_description']);\n  }\n\n  if (res.state !== oauthParams.state) {\n    throw new AuthSdkError('OAuth flow response state doesn\\'t match request state');\n  }\n}\n\nfunction handleOAuthResponse(_x, _x2, _x3, _x4) {\n  return _handleOAuthResponse.apply(this, arguments);\n}\n\nfunction _handleOAuthResponse() {\n  _handleOAuthResponse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(sdk, tokenParams, res, urls) {\n    var pkce, responseType, scopes, clientId, tokenDict, expiresIn, tokenType, accessToken, idToken, refreshToken, now, accessJwt, idJwt, idTokenObj, validationParams;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          pkce = sdk.options.pkce !== false;\n\n          if (!(pkce && (res.code || res.interaction_code))) {\n            _context.next = 3;\n            break;\n          }\n\n          return _context.abrupt(\"return\", sdk.token.exchangeCodeForTokens(Object.assign({}, tokenParams, {\n            authorizationCode: res.code,\n            interactionCode: res.interaction_code\n          }), urls));\n\n        case 3:\n          tokenParams = tokenParams || getDefaultTokenParams(sdk);\n          urls = urls || getOAuthUrls(sdk, tokenParams);\n          responseType = tokenParams.responseType || [];\n\n          if (!Array.isArray(responseType)) {\n            responseType = [responseType];\n          }\n\n          if (res.scope) {\n            scopes = res.scope.split(' ');\n          } else {\n            scopes = clone(tokenParams.scopes);\n          }\n\n          clientId = tokenParams.clientId || sdk.options.clientId;\n          validateResponse(res, tokenParams);\n          tokenDict = {};\n          expiresIn = res.expires_in;\n          tokenType = res.token_type;\n          accessToken = res.access_token;\n          idToken = res.id_token;\n          refreshToken = res.refresh_token;\n          now = Math.floor(Date.now() / 1000);\n\n          if (accessToken) {\n            accessJwt = sdk.token.decode(accessToken);\n            tokenDict.accessToken = {\n              accessToken: accessToken,\n              claims: accessJwt.payload,\n              expiresAt: Number(expiresIn) + now,\n              tokenType: tokenType,\n              scopes: scopes,\n              authorizeUrl: urls.authorizeUrl,\n              userinfoUrl: urls.userinfoUrl\n            };\n          }\n\n          if (refreshToken) {\n            tokenDict.refreshToken = {\n              refreshToken: refreshToken,\n              expiresAt: Number(expiresIn) + now,\n              scopes: scopes,\n              tokenUrl: urls.tokenUrl,\n              authorizeUrl: urls.authorizeUrl,\n              issuer: urls.issuer\n            };\n          }\n\n          if (!idToken) {\n            _context.next = 27;\n            break;\n          }\n\n          idJwt = sdk.token.decode(idToken);\n          idTokenObj = {\n            idToken: idToken,\n            claims: idJwt.payload,\n            expiresAt: idJwt.payload.exp - idJwt.payload.iat + now,\n            scopes: scopes,\n            authorizeUrl: urls.authorizeUrl,\n            issuer: urls.issuer,\n            clientId: clientId\n          };\n          validationParams = {\n            clientId: clientId,\n            issuer: urls.issuer,\n            nonce: tokenParams.nonce,\n            accessToken: accessToken\n          };\n\n          if (tokenParams.ignoreSignature !== undefined) {\n            validationParams.ignoreSignature = tokenParams.ignoreSignature;\n          }\n\n          _context.next = 26;\n          return verifyToken(sdk, idTokenObj, validationParams);\n\n        case 26:\n          tokenDict.idToken = idTokenObj;\n\n        case 27:\n          if (!(responseType.indexOf('token') !== -1 && !tokenDict.accessToken)) {\n            _context.next = 29;\n            break;\n          }\n\n          throw new AuthSdkError('Unable to parse OAuth flow response: response type \"token\" was requested but \"access_token\" was not returned.');\n\n        case 29:\n          if (!(responseType.indexOf('id_token') !== -1 && !tokenDict.idToken)) {\n            _context.next = 31;\n            break;\n          }\n\n          throw new AuthSdkError('Unable to parse OAuth flow response: response type \"id_token\" was requested but \"id_token\" was not returned.');\n\n        case 31:\n          return _context.abrupt(\"return\", {\n            tokens: tokenDict,\n            state: res.state,\n            code: res.code\n          });\n\n        case 32:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _handleOAuthResponse.apply(this, arguments);\n}\n\nexport { handleOAuthResponse }; //# sourceMappingURL=handleOAuthResponse.js.map","map":null,"metadata":{},"sourceType":"module"}