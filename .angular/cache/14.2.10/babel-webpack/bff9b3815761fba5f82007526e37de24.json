{"ast":null,"code":"import _regeneratorRuntime from \"/Users/jeffersonhaw/Documents/CebPacAngular/samples-js-angular/okta-hosted-login/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/jeffersonhaw/Documents/CebPacAngular/samples-js-angular/okta-hosted-login/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/jeffersonhaw/Documents/CebPacAngular/samples-js-angular/okta-hosted-login/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/jeffersonhaw/Documents/CebPacAngular/samples-js-angular/okta-hosted-login/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\nimport { removeNils, clone } from '../util/object.js';\nimport AuthSdkError from '../errors/AuthSdkError.js';\nimport { isLocalhost, isIE11OrLess } from '../features.js';\nimport { REFRESH_TOKEN_STORAGE_KEY, TOKEN_STORAGE_NAME } from '../constants.js';\nimport 'tiny-emitter';\nimport 'js-cookie';\nimport 'cross-fetch';\nimport { validateToken as _validateToken } from './util/validateToken.js';\nimport SdkClock from '../clock.js';\nimport { isRefreshToken, isAccessToken, isIDToken } from './types/Token.js';\nimport { EVENT_EXPIRED, EVENT_RENEWED, EVENT_ADDED, EVENT_REMOVED, EVENT_ERROR, EVENT_SET_STORAGE } from './types/TokenManager.js';\nvar DEFAULT_OPTIONS = {\n  autoRenew: true,\n  autoRemove: true,\n  syncStorage: true,\n  clearPendingRemoveTokens: true,\n  storage: undefined,\n  expireEarlySeconds: 30,\n  storageKey: TOKEN_STORAGE_NAME\n};\n\nfunction defaultState() {\n  return {\n    expireTimeouts: {},\n    renewPromise: null\n  };\n}\n\nvar TokenManager = /*#__PURE__*/function () {\n  function TokenManager(sdk) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, TokenManager);\n\n    this.sdk = sdk;\n    this.emitter = sdk.emitter;\n\n    if (!this.emitter) {\n      throw new AuthSdkError('Emitter should be initialized before TokenManager');\n    }\n\n    options = Object.assign({}, DEFAULT_OPTIONS, removeNils(options));\n\n    if (!isLocalhost()) {\n      options.expireEarlySeconds = DEFAULT_OPTIONS.expireEarlySeconds;\n    }\n\n    this.options = options;\n    var storageOptions = removeNils({\n      storageKey: options.storageKey,\n      secure: options.secure\n    });\n\n    if (typeof options.storage === 'object') {\n      storageOptions.storageProvider = options.storage;\n    } else if (options.storage) {\n      storageOptions.storageType = options.storage;\n    }\n\n    this.storage = sdk.storageManager.getTokenStorage(Object.assign(Object.assign({}, storageOptions), {\n      useSeparateCookies: true\n    }));\n    this.clock = SdkClock.create();\n    this.state = defaultState();\n  }\n\n  _createClass(TokenManager, [{\n    key: \"on\",\n    value: function on(event, handler, context) {\n      if (context) {\n        this.emitter.on(event, handler, context);\n      } else {\n        this.emitter.on(event, handler);\n      }\n    }\n  }, {\n    key: \"off\",\n    value: function off(event, handler) {\n      if (handler) {\n        this.emitter.off(event, handler);\n      } else {\n        this.emitter.off(event);\n      }\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      if (this.options.clearPendingRemoveTokens) {\n        this.clearPendingRemoveTokens();\n      }\n\n      this.setExpireEventTimeoutAll();\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.clearExpireEventTimeoutAll();\n    }\n  }, {\n    key: \"getOptions\",\n    value: function getOptions() {\n      return clone(this.options);\n    }\n  }, {\n    key: \"getExpireTime\",\n    value: function getExpireTime(token) {\n      var expireEarlySeconds = this.options.expireEarlySeconds || 0;\n      var expireTime = token.expiresAt - expireEarlySeconds;\n      return expireTime;\n    }\n  }, {\n    key: \"hasExpired\",\n    value: function hasExpired(token) {\n      var expireTime = this.getExpireTime(token);\n      return expireTime <= this.clock.now();\n    }\n  }, {\n    key: \"emitExpired\",\n    value: function emitExpired(key, token) {\n      this.emitter.emit(EVENT_EXPIRED, key, token);\n    }\n  }, {\n    key: \"emitRenewed\",\n    value: function emitRenewed(key, freshToken, oldToken) {\n      this.emitter.emit(EVENT_RENEWED, key, freshToken, oldToken);\n    }\n  }, {\n    key: \"emitAdded\",\n    value: function emitAdded(key, token) {\n      this.emitter.emit(EVENT_ADDED, key, token);\n    }\n  }, {\n    key: \"emitRemoved\",\n    value: function emitRemoved(key, token) {\n      this.emitter.emit(EVENT_REMOVED, key, token);\n    }\n  }, {\n    key: \"emitError\",\n    value: function emitError(error) {\n      this.emitter.emit(EVENT_ERROR, error);\n    }\n  }, {\n    key: \"clearExpireEventTimeout\",\n    value: function clearExpireEventTimeout(key) {\n      clearTimeout(this.state.expireTimeouts[key]);\n      delete this.state.expireTimeouts[key];\n      this.state.renewPromise = null;\n    }\n  }, {\n    key: \"clearExpireEventTimeoutAll\",\n    value: function clearExpireEventTimeoutAll() {\n      var expireTimeouts = this.state.expireTimeouts;\n\n      for (var key in expireTimeouts) {\n        if (!Object.prototype.hasOwnProperty.call(expireTimeouts, key)) {\n          continue;\n        }\n\n        this.clearExpireEventTimeout(key);\n      }\n    }\n  }, {\n    key: \"setExpireEventTimeout\",\n    value: function setExpireEventTimeout(key, token) {\n      var _this = this;\n\n      if (isRefreshToken(token)) {\n        return;\n      }\n\n      var expireTime = this.getExpireTime(token);\n      var expireEventWait = Math.max(expireTime - this.clock.now(), 0) * 1000;\n      this.clearExpireEventTimeout(key);\n      var expireEventTimeout = setTimeout(function () {\n        _this.emitExpired(key, token);\n      }, expireEventWait);\n      this.state.expireTimeouts[key] = expireEventTimeout;\n    }\n  }, {\n    key: \"setExpireEventTimeoutAll\",\n    value: function setExpireEventTimeoutAll() {\n      var tokenStorage = this.storage.getStorage();\n\n      for (var key in tokenStorage) {\n        if (!Object.prototype.hasOwnProperty.call(tokenStorage, key)) {\n          continue;\n        }\n\n        var token = tokenStorage[key];\n        this.setExpireEventTimeout(key, token);\n      }\n    }\n  }, {\n    key: \"resetExpireEventTimeoutAll\",\n    value: function resetExpireEventTimeoutAll() {\n      this.clearExpireEventTimeoutAll();\n      this.setExpireEventTimeoutAll();\n    }\n  }, {\n    key: \"add\",\n    value: function add(key, token) {\n      var tokenStorage = this.storage.getStorage();\n\n      _validateToken(token);\n\n      tokenStorage[key] = token;\n      this.storage.setStorage(tokenStorage);\n      this.emitSetStorageEvent();\n      this.emitAdded(key, token);\n      this.setExpireEventTimeout(key, token);\n    }\n  }, {\n    key: \"getSync\",\n    value: function getSync(key) {\n      var tokenStorage = this.storage.getStorage();\n      return tokenStorage[key];\n    }\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(key) {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", this.getSync(key));\n\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n\n      function get(_x) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }()\n  }, {\n    key: \"getTokensSync\",\n    value: function getTokensSync() {\n      var tokens = {};\n      var tokenStorage = this.storage.getStorage();\n      Object.keys(tokenStorage).forEach(function (key) {\n        var token = tokenStorage[key];\n\n        if (isAccessToken(token)) {\n          tokens.accessToken = token;\n        } else if (isIDToken(token)) {\n          tokens.idToken = token;\n        } else if (isRefreshToken(token)) {\n          tokens.refreshToken = token;\n        }\n      });\n      return tokens;\n    }\n  }, {\n    key: \"getTokens\",\n    value: function () {\n      var _getTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              return _context2.abrupt(\"return\", this.getTokensSync());\n\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n\n      function getTokens() {\n        return _getTokens.apply(this, arguments);\n      }\n\n      return getTokens;\n    }()\n  }, {\n    key: \"getStorageKeyByType\",\n    value: function getStorageKeyByType(type) {\n      var tokenStorage = this.storage.getStorage();\n      var key = Object.keys(tokenStorage).filter(function (key) {\n        var token = tokenStorage[key];\n        return isAccessToken(token) && type === 'accessToken' || isIDToken(token) && type === 'idToken' || isRefreshToken(token) && type === 'refreshToken';\n      })[0];\n      return key;\n    }\n  }, {\n    key: \"getTokenType\",\n    value: function getTokenType(token) {\n      if (isAccessToken(token)) {\n        return 'accessToken';\n      }\n\n      if (isIDToken(token)) {\n        return 'idToken';\n      }\n\n      if (isRefreshToken(token)) {\n        return 'refreshToken';\n      }\n\n      throw new AuthSdkError('Unknown token type');\n    }\n  }, {\n    key: \"emitSetStorageEvent\",\n    value: function emitSetStorageEvent() {\n      if (isIE11OrLess()) {\n        var storage = this.storage.getStorage();\n        this.emitter.emit(EVENT_SET_STORAGE, storage);\n      }\n    }\n  }, {\n    key: \"getStorage\",\n    value: function getStorage() {\n      return this.storage;\n    }\n  }, {\n    key: \"setTokens\",\n    value: function setTokens(tokens, accessTokenCb, idTokenCb, refreshTokenCb) {\n      var _this2 = this;\n\n      var handleTokenCallback = function handleTokenCallback(key, token) {\n        var type = _this2.getTokenType(token);\n\n        if (type === 'accessToken') {\n          accessTokenCb && accessTokenCb(key, token);\n        } else if (type === 'idToken') {\n          idTokenCb && idTokenCb(key, token);\n        } else if (type === 'refreshToken') {\n          refreshTokenCb && refreshTokenCb(key, token);\n        }\n      };\n\n      var handleAdded = function handleAdded(key, token) {\n        _this2.emitAdded(key, token);\n\n        _this2.setExpireEventTimeout(key, token);\n\n        handleTokenCallback(key, token);\n      };\n\n      var handleRenewed = function handleRenewed(key, token, oldToken) {\n        _this2.emitRenewed(key, token, oldToken);\n\n        _this2.clearExpireEventTimeout(key);\n\n        _this2.setExpireEventTimeout(key, token);\n\n        handleTokenCallback(key, token);\n      };\n\n      var handleRemoved = function handleRemoved(key, token) {\n        _this2.clearExpireEventTimeout(key);\n\n        _this2.emitRemoved(key, token);\n\n        handleTokenCallback(key, token);\n      };\n\n      var types = ['idToken', 'accessToken', 'refreshToken'];\n      var existingTokens = this.getTokensSync();\n      types.forEach(function (type) {\n        var token = tokens[type];\n\n        if (token) {\n          _validateToken(token, type);\n        }\n      });\n      var storage = types.reduce(function (storage, type) {\n        var token = tokens[type];\n\n        if (token) {\n          var storageKey = _this2.getStorageKeyByType(type) || type;\n          storage[storageKey] = token;\n        }\n\n        return storage;\n      }, {});\n      this.storage.setStorage(storage);\n      this.emitSetStorageEvent();\n      types.forEach(function (type) {\n        var newToken = tokens[type];\n        var existingToken = existingTokens[type];\n        var storageKey = _this2.getStorageKeyByType(type) || type;\n\n        if (newToken && existingToken) {\n          handleRemoved(storageKey, existingToken);\n          handleAdded(storageKey, newToken);\n          handleRenewed(storageKey, newToken, existingToken);\n        } else if (newToken) {\n          handleAdded(storageKey, newToken);\n        } else if (existingToken) {\n          handleRemoved(storageKey, existingToken);\n        }\n      });\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(key) {\n      this.clearExpireEventTimeout(key);\n      var tokenStorage = this.storage.getStorage();\n      var removedToken = tokenStorage[key];\n      delete tokenStorage[key];\n      this.storage.setStorage(tokenStorage);\n      this.emitSetStorageEvent();\n      this.emitRemoved(key, removedToken);\n    }\n  }, {\n    key: \"renewToken\",\n    value: function () {\n      var _renewToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(token) {\n        var _a;\n\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              return _context3.abrupt(\"return\", (_a = this.sdk.token) === null || _a === void 0 ? void 0 : _a.renew(token));\n\n            case 1:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n\n      function renewToken(_x2) {\n        return _renewToken.apply(this, arguments);\n      }\n\n      return renewToken;\n    }()\n  }, {\n    key: \"validateToken\",\n    value: function validateToken(token) {\n      return _validateToken(token);\n    }\n  }, {\n    key: \"renew\",\n    value: function renew(key) {\n      var _this3 = this;\n\n      if (this.state.renewPromise) {\n        return this.state.renewPromise;\n      }\n\n      try {\n        var token = this.getSync(key);\n\n        if (!token) {\n          throw new AuthSdkError('The tokenManager has no token for the key: ' + key);\n        }\n      } catch (e) {\n        return Promise.reject(e);\n      }\n\n      this.clearExpireEventTimeout(key);\n      var renewPromise = this.state.renewPromise = this.sdk.token.renewTokens().then(function (tokens) {\n        _this3.setTokens(tokens);\n\n        var tokenType = _this3.getTokenType(token);\n\n        return tokens[tokenType];\n      }).catch(function (err) {\n        _this3.remove(key);\n\n        err.tokenKey = key;\n\n        _this3.emitError(err);\n\n        throw err;\n      }).finally(function () {\n        _this3.state.renewPromise = null;\n      });\n      return renewPromise;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _this4 = this;\n\n      var tokens = this.getTokensSync();\n      this.clearExpireEventTimeoutAll();\n      this.storage.clearStorage();\n      this.emitSetStorageEvent();\n      Object.keys(tokens).forEach(function (key) {\n        _this4.emitRemoved(key, tokens[key]);\n      });\n    }\n  }, {\n    key: \"clearPendingRemoveTokens\",\n    value: function clearPendingRemoveTokens() {\n      var _this5 = this;\n\n      var tokenStorage = this.storage.getStorage();\n      var removedTokens = {};\n      Object.keys(tokenStorage).forEach(function (key) {\n        if (tokenStorage[key].pendingRemove) {\n          removedTokens[key] = tokenStorage[key];\n          delete tokenStorage[key];\n        }\n      });\n      this.storage.setStorage(tokenStorage);\n      this.emitSetStorageEvent();\n      Object.keys(removedTokens).forEach(function (key) {\n        _this5.clearExpireEventTimeout(key);\n\n        _this5.emitRemoved(key, removedTokens[key]);\n      });\n    }\n  }, {\n    key: \"updateRefreshToken\",\n    value: function updateRefreshToken(token) {\n      var key = this.getStorageKeyByType('refreshToken') || REFRESH_TOKEN_STORAGE_KEY;\n      var tokenStorage = this.storage.getStorage();\n\n      _validateToken(token);\n\n      tokenStorage[key] = token;\n      this.storage.setStorage(tokenStorage);\n      this.emitSetStorageEvent();\n    }\n  }, {\n    key: \"removeRefreshToken\",\n    value: function removeRefreshToken() {\n      var key = this.getStorageKeyByType('refreshToken') || REFRESH_TOKEN_STORAGE_KEY;\n      this.remove(key);\n    }\n  }, {\n    key: \"addPendingRemoveFlags\",\n    value: function addPendingRemoveFlags() {\n      var tokens = this.getTokensSync();\n      Object.keys(tokens).forEach(function (key) {\n        tokens[key].pendingRemove = true;\n      });\n      this.setTokens(tokens);\n    }\n  }]);\n\n  return TokenManager;\n}();\n\nexport { TokenManager }; //# sourceMappingURL=TokenManager.js.map","map":null,"metadata":{},"sourceType":"module"}