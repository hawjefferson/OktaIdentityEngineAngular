{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/jeffersonhaw/Documents/CebPacAngular/samples-js-angular/okta-hosted-login/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"/Users/jeffersonhaw/Documents/CebPacAngular/samples-js-angular/okta-hosted-login/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/Users/jeffersonhaw/Documents/CebPacAngular/samples-js-angular/okta-hosted-login/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar model_1 = require(\"./model\");\n\nvar affinity_calculation_strategy_1 = require(\"./helper/affinity-calculation-strategy\");\n\nvar mask_1 = require(\"./helper/mask\");\n\nvar mask_affinity_1 = require(\"./helper/mask-affinity\");\n\nvar MaskedTextChangedListener = /*#__PURE__*/function () {\n  function MaskedTextChangedListener(primaryFormat, field, listener) {\n    var _this = this;\n\n    var affineFormats = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    var customNotations = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n    var affinityCalculationStrategy = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new affinity_calculation_strategy_1.AffinityCalculation(affinity_calculation_strategy_1.AffinityCalculationStrategy.WHOLE_STRING);\n    var autocomplete = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : true;\n\n    _classCallCheck(this, MaskedTextChangedListener);\n\n    this.primaryFormat = primaryFormat;\n    this.field = field;\n    this.listener = listener;\n    this.affineFormats = affineFormats;\n    this.customNotations = customNotations;\n    this.affinityCalculationStrategy = affinityCalculationStrategy;\n    this.autocomplete = autocomplete;\n    this.afterText = '';\n    this.caretPosition = 0;\n\n    this.placeholder = function () {\n      return _this.primaryMask.placeholder();\n    };\n\n    this.acceptableTextLength = function () {\n      return _this.primaryMask.acceptableTextLength();\n    };\n\n    this.totalTextLength = function () {\n      return _this.primaryMask.totalTextLength();\n    };\n\n    this.totalValueLength = function () {\n      return _this.primaryMask.totalValueLength();\n    };\n\n    this.primaryMask = mask_1.Mask.getOrCreate(this.primaryFormat, this.customNotations);\n    this.addEvents(field);\n  }\n\n  _createClass(MaskedTextChangedListener, [{\n    key: \"setText\",\n    value: function setText(text) {\n      var result = null;\n\n      if (!this.field.value || this.field.value === '') {\n        result = this._setText(text, this.field);\n        this.afterText = result.formattedText.str;\n        this.caretPosition = result.formattedText.caretPosition;\n\n        if (!!this.listener) {\n          this.listener.onTextChanged(result.complete, result.extractedValue, this.afterText);\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_setText\",\n    value: function _setText(text, field) {\n      var result = this.pickMask(text, text.length, this.autocomplete).apply(new model_1.CaretString(text, text.length), this.autocomplete);\n      field.value = String(result.formattedText.str);\n      field.setSelectionRange(result.formattedText.caretPosition, result.formattedText.caretPosition);\n      return result;\n    }\n  }, {\n    key: \"pickMask\",\n    value: function pickMask(text, caretPosition, autocomplete) {\n      text = String(text);\n\n      if (this.affineFormats.length === 0) {\n        return this.primaryMask;\n      }\n\n      var primaryAffinity = this.calculateAffinity(this.primaryMask, text, caretPosition, autocomplete);\n      var maskAndAffinities = [];\n\n      var _iterator = _createForOfIteratorHelper(this.affineFormats),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var format = _step.value;\n          var mask = new mask_1.Mask(format, this.customNotations);\n          var affinity = this.calculateAffinity(mask, text, caretPosition, autocomplete);\n          maskAndAffinities.push(new mask_affinity_1.MaskAffinity(mask, affinity));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      maskAndAffinities.sort(function (a, b) {\n        return b.affinity - a.affinity;\n      });\n      var insertIndex = -1;\n      maskAndAffinities.some(function (maskAffinity, index) {\n        if (primaryAffinity >= maskAffinity.affinity) {\n          insertIndex = index;\n        }\n\n        return primaryAffinity >= maskAffinity.affinity;\n      });\n\n      if (insertIndex >= 0) {\n        maskAndAffinities[insertIndex] = new mask_affinity_1.MaskAffinity(this.primaryMask, primaryAffinity);\n      } else {\n        maskAndAffinities.push(new mask_affinity_1.MaskAffinity(this.primaryMask, primaryAffinity));\n      }\n\n      return maskAndAffinities[0].mask;\n    }\n  }, {\n    key: \"calculateAffinity\",\n    value: function calculateAffinity(mask, text, caretPosition, autocomplete) {\n      return this.affinityCalculationStrategy.calculateAffinityOfMask(mask, new model_1.CaretString(text, caretPosition), autocomplete);\n    }\n  }, {\n    key: \"addEvents\",\n    value: function addEvents(field) {\n      var _this2 = this;\n\n      field.addEventListener('input', function (ev) {\n        _this2.onTextChanged(field.value, ev);\n      });\n      field.addEventListener('focus', function (ev) {\n        _this2.onFocusChange(true);\n      });\n      field.addEventListener('blur', function (ev) {\n        _this2.onFocusChange(false);\n      });\n    }\n  }, {\n    key: \"onFocusChange\",\n    value: function onFocusChange(hasFocus) {\n      if (this.autocomplete && hasFocus) {\n        var text = !!this.field.value ? this.field.value : '';\n        var result = this.pickMask(text, text.length, this.autocomplete).apply(new model_1.CaretString(text, text.length), this.autocomplete);\n        this.afterText = result.formattedText.str;\n        this.caretPosition = result.formattedText.caretPosition;\n        this.field.value = String(this.afterText);\n        this.field.setSelectionRange(result.formattedText.caretPosition, result.formattedText.caretPosition);\n\n        if (!!this.listener) {\n          this.listener.onTextChanged(result.complete, result.extractedValue, this.afterText);\n        }\n      }\n    }\n  }, {\n    key: \"onTextChanged\",\n    value: function onTextChanged(text, event) {\n      var isDeletion = event.inputType === 'deleteContentForward' || event.inputType === 'deleteContentBackward';\n      var isInside = this.field.selectionStart < text.length;\n      var caretPosition = isDeletion || isInside ? this.field.selectionStart : text.length;\n      var result = this.pickMask(text, caretPosition, this.autocomplete && !isDeletion).apply(new model_1.CaretString(text, caretPosition), this.autocomplete && !isDeletion);\n      this.afterText = result.formattedText.str;\n      this.caretPosition = isDeletion || isInside ? this.field.selectionStart : result.formattedText.caretPosition;\n      this.field.value = String(this.afterText);\n      this.field.setSelectionRange(this.caretPosition, this.caretPosition);\n\n      if (!!this.listener) {\n        this.listener.onTextChanged(result.complete, result.extractedValue, this.afterText);\n      }\n    }\n  }], [{\n    key: \"installOn\",\n    value: function installOn(primaryFormat, field, listener) {\n      var affineFormats = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n      var customNotations = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n      var affinityCalculationStrategy = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new affinity_calculation_strategy_1.AffinityCalculation(affinity_calculation_strategy_1.AffinityCalculationStrategy.WHOLE_STRING);\n      var autocomplete = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : true;\n      return new MaskedTextChangedListener(primaryFormat, field, listener, affineFormats, customNotations, affinityCalculationStrategy, autocomplete);\n    }\n  }]);\n\n  return MaskedTextChangedListener;\n}();\n\nexports.MaskedTextChangedListener = MaskedTextChangedListener;","map":null,"metadata":{},"sourceType":"script"}