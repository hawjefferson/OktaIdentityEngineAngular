{"ast":null,"code":"import _slicedToArray from \"/Users/jeffersonhaw/Documents/CebPacAngular/samples-js-angular/okta-hosted-login/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\nimport { __rest } from '../../../_virtual/_tslib.js';\nimport { generateRemediationFunctions } from './remediationParser.js';\nimport generateIdxAction from './generateIdxAction.js';\nimport { JSONPath } from 'jsonpath-plus';\nvar SKIP_FIELDS = Object.fromEntries(['remediation', 'context'].map(function (field) {\n  return [field, !!'skip this field'];\n}));\n\nvar parseNonRemediations = function parseNonRemediations(authClient, idxResponse) {\n  var toPersist = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var actions = {};\n  var context = {};\n  Object.keys(idxResponse).filter(function (field) {\n    return !SKIP_FIELDS[field];\n  }).forEach(function (field) {\n    var fieldIsObject = typeof idxResponse[field] === 'object' && !!idxResponse[field];\n\n    if (!fieldIsObject) {\n      context[field] = idxResponse[field];\n      return;\n    }\n\n    if (idxResponse[field].rel) {\n      actions[idxResponse[field].name] = generateIdxAction(authClient, idxResponse[field], toPersist);\n      return;\n    }\n\n    var _a = idxResponse[field],\n        fieldValue = _a.value,\n        type = _a.type,\n        info = __rest(_a, [\"value\", \"type\"]);\n\n    context[field] = Object.assign({\n      type: type\n    }, info);\n\n    if (type !== 'object') {\n      context[field].value = fieldValue;\n      return;\n    }\n\n    context[field].value = {};\n    Object.entries(fieldValue).forEach(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          subField = _ref2[0],\n          value = _ref2[1];\n\n      if (value.rel) {\n        actions[\"\".concat(field, \"-\").concat(subField.name || subField)] = generateIdxAction(authClient, value, toPersist);\n      } else {\n        context[field].value[subField] = value;\n      }\n    });\n  });\n  return {\n    context: context,\n    actions: actions\n  };\n};\n\nvar expandRelatesTo = function expandRelatesTo(idxResponse, value) {\n  Object.keys(value).forEach(function (k) {\n    if (k === 'relatesTo') {\n      var query = Array.isArray(value[k]) ? value[k][0] : value[k];\n\n      if (typeof query === 'string') {\n        var result = JSONPath({\n          path: query,\n          json: idxResponse\n        })[0];\n\n        if (result) {\n          value[k] = result;\n          return;\n        }\n      }\n    }\n\n    if (Array.isArray(value[k])) {\n      value[k].forEach(function (innerValue) {\n        return expandRelatesTo(idxResponse, innerValue);\n      });\n    }\n  });\n};\n\nvar convertRemediationAction = function convertRemediationAction(authClient, remediation, toPersist) {\n  if (remediation.rel) {\n    var remediationActions = generateRemediationFunctions(authClient, [remediation], toPersist);\n    var actionFn = remediationActions[remediation.name];\n    return Object.assign(Object.assign({}, remediation), {\n      action: actionFn\n    });\n  }\n\n  return remediation;\n};\n\nvar parseIdxResponse = function parseIdxResponse(authClient, idxResponse) {\n  var toPersist = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var _a;\n\n  var remediationData = ((_a = idxResponse.remediation) === null || _a === void 0 ? void 0 : _a.value) || [];\n  remediationData.forEach(function (remediation) {\n    return expandRelatesTo(idxResponse, remediation);\n  });\n  var remediations = remediationData.map(function (remediation) {\n    return convertRemediationAction(authClient, remediation, toPersist);\n  });\n\n  var _parseNonRemediations = parseNonRemediations(authClient, idxResponse, toPersist),\n      context = _parseNonRemediations.context,\n      actions = _parseNonRemediations.actions;\n\n  return {\n    remediations: remediations,\n    context: context,\n    actions: actions\n  };\n};\n\nexport { parseIdxResponse, parseNonRemediations }; //# sourceMappingURL=idxResponseParser.js.map","map":null,"metadata":{},"sourceType":"module"}