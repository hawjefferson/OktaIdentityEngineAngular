{"ast":null,"code":"import _regeneratorRuntime from \"/Users/jeffersonhaw/Documents/CebPacAngular/samples-js-angular/okta-hosted-login/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/jeffersonhaw/Documents/CebPacAngular/samples-js-angular/okta-hosted-login/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/jeffersonhaw/Documents/CebPacAngular/samples-js-angular/okta-hosted-login/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/jeffersonhaw/Documents/CebPacAngular/samples-js-angular/okta-hosted-login/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\nimport PCancelable from 'p-cancelable';\nimport AuthSdkError from '../errors/AuthSdkError.js';\nimport { getConsole } from '../util/console.js';\nimport { PromiseQueue } from '../util/PromiseQueue.js';\nimport 'tiny-emitter';\nimport 'js-cookie';\nimport 'cross-fetch';\nimport { EVENT_ADDED, EVENT_REMOVED } from '../oidc/types/TokenManager.js';\nvar INITIAL_AUTH_STATE = null;\nvar DEFAULT_PENDING = {\n  updateAuthStatePromise: null,\n  canceledTimes: 0\n};\nvar EVENT_AUTH_STATE_CHANGE = 'authStateChange';\nvar MAX_PROMISE_CANCEL_TIMES = 10;\n\nvar isSameAuthState = function isSameAuthState(prevState, state) {\n  if (!prevState) {\n    return false;\n  }\n\n  return prevState.isAuthenticated === state.isAuthenticated && JSON.stringify(prevState.idToken) === JSON.stringify(state.idToken) && JSON.stringify(prevState.accessToken) === JSON.stringify(state.accessToken) && prevState.error === state.error;\n};\n\nvar AuthStateManager = /*#__PURE__*/function () {\n  function AuthStateManager(sdk) {\n    var _this = this;\n\n    _classCallCheck(this, AuthStateManager);\n\n    if (!sdk.emitter) {\n      throw new AuthSdkError('Emitter should be initialized before AuthStateManager');\n    }\n\n    this._sdk = sdk;\n    this._pending = Object.assign({}, DEFAULT_PENDING);\n    this._authState = INITIAL_AUTH_STATE;\n    this._logOptions = {};\n    this._prevAuthState = null;\n    this._transformQueue = new PromiseQueue({\n      quiet: true\n    });\n    sdk.tokenManager.on(EVENT_ADDED, function (key, token) {\n      _this._setLogOptions({\n        event: EVENT_ADDED,\n        key: key,\n        token: token\n      });\n\n      _this.updateAuthState();\n    });\n    sdk.tokenManager.on(EVENT_REMOVED, function (key, token) {\n      _this._setLogOptions({\n        event: EVENT_REMOVED,\n        key: key,\n        token: token\n      });\n\n      _this.updateAuthState();\n    });\n  }\n\n  _createClass(AuthStateManager, [{\n    key: \"_setLogOptions\",\n    value: function _setLogOptions(options) {\n      this._logOptions = options;\n    }\n  }, {\n    key: \"getAuthState\",\n    value: function getAuthState() {\n      return this._authState;\n    }\n  }, {\n    key: \"getPreviousAuthState\",\n    value: function getPreviousAuthState() {\n      return this._prevAuthState;\n    }\n  }, {\n    key: \"updateAuthState\",\n    value: function () {\n      var _updateAuthState = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _this2 = this;\n\n        var _this$_sdk$options, transformAuthState, devMode, log, emitAuthStateChange, finalPromise, cancelablePromise;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _this$_sdk$options = this._sdk.options, transformAuthState = _this$_sdk$options.transformAuthState, devMode = _this$_sdk$options.devMode;\n\n              log = function log(status) {\n                var _this2$_logOptions = _this2._logOptions,\n                    event = _this2$_logOptions.event,\n                    key = _this2$_logOptions.key,\n                    token = _this2$_logOptions.token;\n                getConsole().group(\"OKTA-AUTH-JS:updateAuthState: Event:\".concat(event, \" Status:\").concat(status));\n                getConsole().log(key, token);\n                getConsole().log('Current authState', _this2._authState);\n                getConsole().groupEnd();\n                _this2._logOptions = {};\n              };\n\n              emitAuthStateChange = function emitAuthStateChange(authState) {\n                if (isSameAuthState(_this2._authState, authState)) {\n                  devMode && log('unchanged');\n                  return;\n                }\n\n                _this2._prevAuthState = _this2._authState;\n                _this2._authState = authState;\n\n                _this2._sdk.emitter.emit(EVENT_AUTH_STATE_CHANGE, Object.assign({}, authState));\n\n                devMode && log('emitted');\n              };\n\n              finalPromise = function finalPromise(origPromise) {\n                return _this2._pending.updateAuthStatePromise.then(function () {\n                  var curPromise = _this2._pending.updateAuthStatePromise;\n\n                  if (curPromise && curPromise !== origPromise) {\n                    return finalPromise(curPromise);\n                  }\n\n                  return _this2.getAuthState();\n                });\n              };\n\n              if (!this._pending.updateAuthStatePromise) {\n                _context.next = 11;\n                break;\n              }\n\n              if (!(this._pending.canceledTimes >= MAX_PROMISE_CANCEL_TIMES)) {\n                _context.next = 10;\n                break;\n              }\n\n              devMode && log('terminated');\n              return _context.abrupt(\"return\", finalPromise(this._pending.updateAuthStatePromise));\n\n            case 10:\n              this._pending.updateAuthStatePromise.cancel();\n\n            case 11:\n              cancelablePromise = new PCancelable(function (resolve, _, onCancel) {\n                onCancel.shouldReject = false;\n                onCancel(function () {\n                  _this2._pending.updateAuthStatePromise = null;\n                  _this2._pending.canceledTimes = _this2._pending.canceledTimes + 1;\n                  devMode && log('canceled');\n                });\n\n                var emitAndResolve = function emitAndResolve(authState) {\n                  if (cancelablePromise.isCanceled) {\n                    resolve();\n                    return;\n                  }\n\n                  emitAuthStateChange(authState);\n                  resolve();\n                  _this2._pending = Object.assign({}, DEFAULT_PENDING);\n                };\n\n                _this2._sdk.isAuthenticated().then(function () {\n                  if (cancelablePromise.isCanceled) {\n                    resolve();\n                    return;\n                  }\n\n                  var _this2$_sdk$tokenMana = _this2._sdk.tokenManager.getTokensSync(),\n                      accessToken = _this2$_sdk$tokenMana.accessToken,\n                      idToken = _this2$_sdk$tokenMana.idToken,\n                      refreshToken = _this2$_sdk$tokenMana.refreshToken;\n\n                  var authState = {\n                    accessToken: accessToken,\n                    idToken: idToken,\n                    refreshToken: refreshToken,\n                    isAuthenticated: !!(accessToken && idToken)\n                  };\n                  var promise = transformAuthState ? _this2._transformQueue.push(transformAuthState, null, _this2._sdk, authState) : Promise.resolve(authState);\n                  promise.then(function (authState) {\n                    return emitAndResolve(authState);\n                  }).catch(function (error) {\n                    return emitAndResolve({\n                      accessToken: accessToken,\n                      idToken: idToken,\n                      refreshToken: refreshToken,\n                      isAuthenticated: false,\n                      error: error\n                    });\n                  });\n                });\n              });\n              this._pending.updateAuthStatePromise = cancelablePromise;\n              return _context.abrupt(\"return\", finalPromise(cancelablePromise));\n\n            case 14:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n\n      function updateAuthState() {\n        return _updateAuthState.apply(this, arguments);\n      }\n\n      return updateAuthState;\n    }()\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(handler) {\n      this._sdk.emitter.on(EVENT_AUTH_STATE_CHANGE, handler);\n    }\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(handler) {\n      this._sdk.emitter.off(EVENT_AUTH_STATE_CHANGE, handler);\n    }\n  }]);\n\n  return AuthStateManager;\n}();\n\nexport { AuthStateManager, INITIAL_AUTH_STATE }; //# sourceMappingURL=AuthStateManager.js.map","map":null,"metadata":{},"sourceType":"module"}