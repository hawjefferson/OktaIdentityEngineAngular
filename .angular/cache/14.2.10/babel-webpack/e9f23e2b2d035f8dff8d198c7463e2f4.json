{"ast":null,"code":"import _regeneratorRuntime from \"/Users/jeffersonhaw/Documents/CebPacAngular/samples-js-angular/okta-hosted-login/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/jeffersonhaw/Documents/CebPacAngular/samples-js-angular/okta-hosted-login/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"/Users/jeffersonhaw/Documents/CebPacAngular/samples-js-angular/okta-hosted-login/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/jeffersonhaw/Documents/CebPacAngular/samples-js-angular/okta-hosted-login/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/Users/jeffersonhaw/Documents/CebPacAngular/samples-js-angular/okta-hosted-login/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\n\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\nimport { __rest } from '../_virtual/_tslib.js';\nimport { warn } from '../util/console.js';\nimport { split2 } from '../util/misc.js';\nimport * as index from './remediators/index.js';\nimport { GenericRemediator } from './remediators/GenericRemediator/GenericRemediator.js';\nimport { IdxFeature } from './types/api.js';\n\nfunction isTerminalResponse(idxResponse) {\n  var neededToProceed = idxResponse.neededToProceed,\n      interactionCode = idxResponse.interactionCode;\n  return !neededToProceed.length && !interactionCode;\n}\n\nfunction canSkipFn(idxResponse) {\n  return idxResponse.neededToProceed.some(function (_ref) {\n    var name = _ref.name;\n    return name === 'skip';\n  });\n}\n\nfunction canResendFn(idxResponse) {\n  return Object.keys(idxResponse.actions).some(function (actionName) {\n    return actionName.includes('resend');\n  });\n}\n\nfunction getMessagesFromIdxRemediationValue(value) {\n  if (!value || !Array.isArray(value)) {\n    return;\n  }\n\n  return value.reduce(function (messages, value) {\n    if (value.messages) {\n      messages = [].concat(_toConsumableArray(messages), _toConsumableArray(value.messages.value));\n    }\n\n    if (value.form) {\n      var messagesFromForm = getMessagesFromIdxRemediationValue(value.form.value) || [];\n      messages = [].concat(_toConsumableArray(messages), _toConsumableArray(messagesFromForm));\n    }\n\n    if (value.options) {\n      var optionValues = [];\n      value.options.forEach(function (option) {\n        if (!option.value || typeof option.value === 'string') {\n          return;\n        }\n\n        optionValues = [].concat(_toConsumableArray(optionValues), [option.value]);\n      });\n      var messagesFromOptions = getMessagesFromIdxRemediationValue(optionValues) || [];\n      messages = [].concat(_toConsumableArray(messages), _toConsumableArray(messagesFromOptions));\n    }\n\n    return messages;\n  }, []);\n}\n\nfunction getMessagesFromResponse(idxResponse, options) {\n  var _a;\n\n  var messages = [];\n  var rawIdxState = idxResponse.rawIdxState,\n      neededToProceed = idxResponse.neededToProceed;\n  var globalMessages = (_a = rawIdxState.messages) === null || _a === void 0 ? void 0 : _a.value.map(function (message) {\n    return message;\n  });\n\n  if (globalMessages) {\n    messages = [].concat(_toConsumableArray(messages), _toConsumableArray(globalMessages));\n  }\n\n  if (!options.useGenericRemediator) {\n    var _iterator = _createForOfIteratorHelper(neededToProceed),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var remediation = _step.value;\n        var fieldMessages = getMessagesFromIdxRemediationValue(remediation.value);\n\n        if (fieldMessages) {\n          messages = [].concat(_toConsumableArray(messages), _toConsumableArray(fieldMessages));\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  var seen = {};\n  messages = messages.reduce(function (filtered, message) {\n    var _a;\n\n    var key = (_a = message.i18n) === null || _a === void 0 ? void 0 : _a.key;\n\n    if (key && seen[key]) {\n      return filtered;\n    }\n\n    seen[key] = message;\n    filtered = [].concat(_toConsumableArray(filtered), [message]);\n    return filtered;\n  }, []);\n  return messages;\n}\n\nfunction getEnabledFeatures(idxResponse) {\n  var res = [];\n  var actions = idxResponse.actions,\n      neededToProceed = idxResponse.neededToProceed;\n\n  if (actions['currentAuthenticator-recover']) {\n    res.push(IdxFeature.PASSWORD_RECOVERY);\n  }\n\n  if (neededToProceed.some(function (_ref2) {\n    var name = _ref2.name;\n    return name === 'select-enroll-profile';\n  })) {\n    res.push(IdxFeature.REGISTRATION);\n  }\n\n  if (neededToProceed.some(function (_ref3) {\n    var name = _ref3.name;\n    return name === 'redirect-idp';\n  })) {\n    res.push(IdxFeature.SOCIAL_IDP);\n  }\n\n  if (neededToProceed.some(function (_ref4) {\n    var name = _ref4.name;\n    return name === 'unlock-account';\n  })) {\n    res.push(IdxFeature.ACCOUNT_UNLOCK);\n  }\n\n  return res;\n}\n\nfunction getAvailableSteps(authClient, idxResponse, useGenericRemediator) {\n  var _a;\n\n  var res = [];\n  var remediatorMap = Object.values(index).reduce(function (map, remediatorClass) {\n    if (remediatorClass.remediationName) {\n      map[remediatorClass.remediationName] = remediatorClass;\n    }\n\n    return map;\n  }, {});\n\n  var _iterator2 = _createForOfIteratorHelper(idxResponse.neededToProceed),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var remediation = _step2.value;\n      var T = getRemediatorClass(remediation, {\n        useGenericRemediator: useGenericRemediator,\n        remediators: remediatorMap\n      });\n\n      if (T) {\n        var remediator = new T(remediation);\n        res.push(remediator.getNextStep(authClient, idxResponse.context));\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  var _loop = function _loop() {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 1),\n        name = _Object$entries$_i[0];\n\n    var stepObj = {\n      name: name,\n      action: function () {\n        var _action = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(params) {\n          return _regeneratorRuntime().wrap(function _callee$(_context) {\n            while (1) switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", authClient.idx.proceed({\n                  actions: [{\n                    name: name,\n                    params: params\n                  }]\n                }));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }, _callee);\n        }));\n\n        function action(_x) {\n          return _action.apply(this, arguments);\n        }\n\n        return action;\n      }()\n    };\n\n    if (name.startsWith('currentAuthenticator')) {\n      var _split = split2(name, '-'),\n          _split2 = _slicedToArray(_split, 2),\n          part1 = _split2[0],\n          part2 = _split2[1];\n\n      var actionObj = idxResponse.rawIdxState[part1].value[part2];\n\n      var rest = __rest(actionObj, [\"href\", \"method\", \"rel\", \"accepts\", \"produces\"]);\n\n      var value = (_a = actionObj.value) === null || _a === void 0 ? void 0 : _a.filter(function (item) {\n        return item.name !== 'stateHandle';\n      });\n      stepObj = Object.assign(Object.assign(Object.assign({}, rest), value && {\n        value: value\n      }), stepObj);\n    }\n\n    res.push(stepObj);\n  };\n\n  for (var _i = 0, _Object$entries = Object.entries(idxResponse.actions || {}); _i < _Object$entries.length; _i++) {\n    _loop();\n  }\n\n  return res;\n}\n\nfunction filterValuesForRemediation(idxResponse, remediationName, values) {\n  var remediations = idxResponse.neededToProceed || [];\n  var remediation = remediations.find(function (r) {\n    return r.name === remediationName;\n  });\n\n  if (!remediation) {\n    warn(\"filterValuesForRemediation: \\\"\".concat(remediationName, \"\\\" did not match any remediations\"));\n    return values;\n  }\n\n  var valuesForRemediation = remediation.value.reduce(function (res, entry) {\n    var name = entry.name,\n        value = entry.value;\n\n    if (name === 'stateHandle') {\n      res[name] = value;\n    } else {\n      res[name] = values[name];\n    }\n\n    return res;\n  }, {});\n  return valuesForRemediation;\n}\n\nfunction getRemediatorClass(remediation, options) {\n  var useGenericRemediator = options.useGenericRemediator,\n      remediators = options.remediators;\n\n  if (!remediation) {\n    return undefined;\n  }\n\n  if (useGenericRemediator) {\n    return GenericRemediator;\n  }\n\n  return remediators[remediation.name];\n}\n\nfunction getRemediator(idxRemediations, values, options) {\n  var remediators = options.remediators;\n  var useGenericRemediator = options.useGenericRemediator;\n  var remediator;\n\n  if (options.step) {\n    var remediation = idxRemediations.find(function (_ref5) {\n      var name = _ref5.name;\n      return name === options.step;\n    });\n\n    if (remediation) {\n      var T = getRemediatorClass(remediation, options);\n      return T ? new T(remediation, values, options) : undefined;\n    } else {\n      warn(\"step \\\"\".concat(options.step, \"\\\" did not match any remediations\"));\n      return;\n    }\n  }\n\n  var remediatorCandidates = [];\n\n  if (useGenericRemediator) {\n    remediatorCandidates.push(new GenericRemediator(idxRemediations[0], values, options));\n  } else {\n    var _iterator3 = _createForOfIteratorHelper(idxRemediations),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var _remediation = _step3.value;\n        var isRemeditionInFlow = Object.keys(remediators).includes(_remediation.name);\n\n        if (!isRemeditionInFlow) {\n          continue;\n        }\n\n        var _T = getRemediatorClass(_remediation, options);\n\n        remediator = new _T(_remediation, values, options);\n\n        if (remediator.canRemediate()) {\n          return remediator;\n        }\n\n        remediatorCandidates.push(remediator);\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n\n  return remediatorCandidates[0];\n}\n\nfunction getNextStep(authClient, remediator, idxResponse) {\n  var nextStep = remediator.getNextStep(authClient, idxResponse.context);\n  var canSkip = canSkipFn(idxResponse);\n  var canResend = canResendFn(idxResponse);\n  return Object.assign(Object.assign(Object.assign({}, nextStep), canSkip && {\n    canSkip: canSkip\n  }), canResend && {\n    canResend: canResend\n  });\n}\n\nfunction handleFailedResponse(authClient, idxResponse) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var terminal = isTerminalResponse(idxResponse);\n  var messages = getMessagesFromResponse(idxResponse, options);\n\n  if (terminal) {\n    return {\n      idxResponse: idxResponse,\n      terminal: terminal,\n      messages: messages\n    };\n  } else {\n    var remediator = getRemediator(idxResponse.neededToProceed, {}, options);\n    var nextStep = remediator && getNextStep(authClient, remediator, idxResponse);\n    return Object.assign({\n      idxResponse: idxResponse,\n      messages: messages\n    }, nextStep && {\n      nextStep: nextStep\n    });\n  }\n}\n\nexport { canResendFn, canSkipFn, filterValuesForRemediation, getAvailableSteps, getEnabledFeatures, getMessagesFromIdxRemediationValue, getMessagesFromResponse, getNextStep, getRemediator, handleFailedResponse, isTerminalResponse }; //# sourceMappingURL=util.js.map","map":null,"metadata":{},"sourceType":"module"}