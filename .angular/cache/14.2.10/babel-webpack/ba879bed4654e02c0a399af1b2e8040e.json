{"ast":null,"code":"import _regeneratorRuntime from \"/Users/jeffersonhaw/Documents/CebPacAngular/samples-js-angular/okta-hosted-login/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/jeffersonhaw/Documents/CebPacAngular/samples-js-angular/okta-hosted-login/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\nimport { warn } from '../util/console.js';\nimport { removeNils } from '../util/object.js';\nimport { createOAuthMeta } from '../oidc/util/oauthMeta.js';\nimport 'tiny-emitter';\nimport 'js-cookie';\nimport 'cross-fetch';\n\nfunction createTransactionMeta(_x) {\n  return _createTransactionMeta.apply(this, arguments);\n}\n\nfunction _createTransactionMeta() {\n  _createTransactionMeta = _asyncToGenerator(function (authClient) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      var tokenParams, pkceMeta, _Object$assign, _Object$assign$flow, flow, _Object$assign$withCr, withCredentials, _Object$assign$activa, activationToken, _Object$assign$recove, recoveryToken, _Object$assign$maxAge, maxAge, meta;\n\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return authClient.token.prepareTokenParams(options);\n\n          case 2:\n            tokenParams = _context.sent;\n            pkceMeta = createOAuthMeta(authClient, tokenParams);\n            _Object$assign = Object.assign(Object.assign({}, authClient.options), options), _Object$assign$flow = _Object$assign.flow, flow = _Object$assign$flow === void 0 ? 'default' : _Object$assign$flow, _Object$assign$withCr = _Object$assign.withCredentials, withCredentials = _Object$assign$withCr === void 0 ? true : _Object$assign$withCr, _Object$assign$activa = _Object$assign.activationToken, activationToken = _Object$assign$activa === void 0 ? undefined : _Object$assign$activa, _Object$assign$recove = _Object$assign.recoveryToken, recoveryToken = _Object$assign$recove === void 0 ? undefined : _Object$assign$recove, _Object$assign$maxAge = _Object$assign.maxAge, maxAge = _Object$assign$maxAge === void 0 ? undefined : _Object$assign$maxAge;\n            meta = Object.assign(Object.assign({}, pkceMeta), {\n              flow: flow,\n              withCredentials: withCredentials,\n              activationToken: activationToken,\n              recoveryToken: recoveryToken,\n              maxAge: maxAge\n            });\n            return _context.abrupt(\"return\", meta);\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    })();\n  });\n  return _createTransactionMeta.apply(this, arguments);\n}\n\nfunction hasSavedInteractionHandle(authClient, options) {\n  var savedMeta = getSavedTransactionMeta(authClient, options);\n\n  if (savedMeta === null || savedMeta === void 0 ? void 0 : savedMeta.interactionHandle) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction getSavedTransactionMeta(authClient, options) {\n  options = removeNils(options);\n  options = Object.assign(Object.assign({}, authClient.options), options);\n  var savedMeta;\n\n  try {\n    savedMeta = authClient.transactionManager.load(options);\n  } catch (e) {}\n\n  if (!savedMeta) {\n    return;\n  }\n\n  if (isTransactionMetaValid(savedMeta, options)) {\n    return savedMeta;\n  }\n\n  warn('Saved transaction meta does not match the current configuration. ' + 'This may indicate that two apps are sharing a storage key.');\n}\n\nfunction getTransactionMeta(_x2, _x3) {\n  return _getTransactionMeta.apply(this, arguments);\n}\n\nfunction _getTransactionMeta() {\n  _getTransactionMeta = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(authClient, options) {\n    var validExistingMeta;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          options = removeNils(options);\n          options = Object.assign(Object.assign({}, authClient.options), options);\n          validExistingMeta = getSavedTransactionMeta(authClient, options);\n\n          if (!validExistingMeta) {\n            _context2.next = 5;\n            break;\n          }\n\n          return _context2.abrupt(\"return\", validExistingMeta);\n\n        case 5:\n          return _context2.abrupt(\"return\", createTransactionMeta(authClient, options));\n\n        case 6:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _getTransactionMeta.apply(this, arguments);\n}\n\nfunction saveTransactionMeta(authClient, meta) {\n  authClient.transactionManager.save(meta, {\n    muteWarning: true\n  });\n}\n\nfunction clearTransactionMeta(authClient) {\n  authClient.transactionManager.clear();\n}\n\nfunction isTransactionMetaValid(meta) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var keys = ['issuer', 'clientId', 'redirectUri', 'state', 'codeChallenge', 'codeChallengeMethod', 'activationToken', 'recoveryToken'];\n\n  if (isTransactionMetaValidForOptions(meta, options, keys) === false) {\n    return false;\n  }\n\n  var flow = options.flow;\n\n  if (isTransactionMetaValidForFlow(meta, flow) === false) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isTransactionMetaValidForFlow(meta, flow) {\n  var shouldValidateFlow = flow && flow !== 'default' && flow !== 'proceed';\n\n  if (shouldValidateFlow) {\n    if (flow !== meta.flow) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isTransactionMetaValidForOptions(meta, options, keys) {\n  var mismatch = keys.some(function (key) {\n    var value = options[key];\n\n    if (value && value !== meta[key]) {\n      return true;\n    }\n  });\n  return !mismatch;\n}\n\nexport { clearTransactionMeta, createTransactionMeta, getSavedTransactionMeta, getTransactionMeta, hasSavedInteractionHandle, isTransactionMetaValid, isTransactionMetaValidForFlow, isTransactionMetaValidForOptions, saveTransactionMeta }; //# sourceMappingURL=transactionMeta.js.map","map":null,"metadata":{},"sourceType":"module"}